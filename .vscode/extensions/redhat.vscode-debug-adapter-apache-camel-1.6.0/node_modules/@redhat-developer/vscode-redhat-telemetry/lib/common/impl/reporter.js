"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reporter = void 0;
const object_hash_1 = require("object-hash");
const logger_1 = require("../utils/logger");
const errorMessages_1 = require("../utils/errorMessages");
/**
 * Sends Telemetry events to a segment.io backend
 */
class Reporter {
    constructor(analytics, cacheService) {
        this.analytics = analytics;
        this.cacheService = cacheService;
    }
    async report(event) {
        if (!this.analytics) {
            return;
        }
        const payloadString = JSON.stringify(event);
        try {
            switch (event.type) {
                case 'identify':
                    //Avoid identifying the user several times, until some data has changed.
                    const hash = (0, object_hash_1.sha1)(payloadString);
                    const cached = await this.cacheService?.get('identify');
                    if (hash === cached) {
                        logger_1.Logger.log(`Skipping 'identify' event! Already sent:\n${payloadString}`);
                        return;
                    }
                    logger_1.Logger.log(`Sending 'identify' event with\n${payloadString}`);
                    await this.analytics?.identify(event);
                    this.cacheService?.put('identify', hash);
                    break;
                case 'track':
                    logger_1.Logger.log(`Sending 'track' event with\n${payloadString}`);
                    await this.analytics?.track(event);
                    break;
                case 'page':
                    logger_1.Logger.log(`Sending 'page' event with\n${payloadString}`);
                    await this.analytics?.page(event);
                    break;
                default:
                    logger_1.Logger.log(`Skipping unsupported (yet?) '${event.type}' event with\n${payloadString}`);
                    break;
            }
        }
        catch (e) {
            logger_1.Logger.log("Failed to send event " + (0, errorMessages_1.toErrorMessage)(e));
        }
    }
    async flush() {
        if (isFlusheable(this.analytics)) {
            this.analytics.flush();
        }
    }
    async closeAndFlush() {
        if (isCloseAndFlusheable(this.analytics)) {
            return this.analytics.closeAndFlush();
        }
    }
}
exports.Reporter = Reporter;
function isFlusheable(object) {
    return 'flush' in object;
}
function isCloseAndFlusheable(object) {
    return 'closeAndFlush' in object;
}
//# sourceMappingURL=reporter.js.map
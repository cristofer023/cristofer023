"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationManager = exports.TELEMETRY_CONFIG = exports.DEFAULT_CONFIG_URL = void 0;
const envVar_1 = __importDefault(require("../envVar"));
const logger_1 = require("../utils/logger");
const configuration_1 = require("./configuration");
exports.DEFAULT_CONFIG_URL = 'https://raw.githubusercontent.com/redhat-developer/vscode-redhat-telemetry/main/src/config/telemetry-config.json';
exports.TELEMETRY_CONFIG = "telemetry-config.json";
class ConfigurationManager {
    constructor(extensionId, storageService) {
        this.extensionId = extensionId;
        this.storageService = storageService;
    }
    async refresh() {
        const remoteConfig = await this.fetchRemoteConfiguration();
        if (remoteConfig) {
            remoteConfig['timestamp'] = new Date().getTime();
            await this.saveLocalConfiguration(remoteConfig);
        }
        return remoteConfig;
    }
    async getExtensionConfiguration() {
        let extensionConfig = this.extensionConfig;
        if (extensionConfig) {
            if (!isStale(await extensionConfig)) {
                return extensionConfig;
            }
            this.extensionConfig = undefined;
        }
        logger_1.Logger.log("Loading json config for " + this.extensionId);
        this.extensionConfig = this.loadConfiguration(this.extensionId);
        return this.extensionConfig;
    }
    async loadConfiguration(extensionId) {
        let localConfig;
        try {
            localConfig = await this.getLocalConfiguration();
            if (isStale(localConfig)) {
                localConfig = await this.refresh();
            }
        }
        catch (e) {
            console.error(`Failed to load local configuration: ${e?.message}`);
        }
        let fullConfig;
        if (localConfig) {
            fullConfig = localConfig;
        }
        else {
            fullConfig = await this.getEmbeddedConfiguration();
        }
        const json = getExtensionConfig(fullConfig, extensionId);
        return new configuration_1.Configuration(json);
    }
    async saveLocalConfiguration(fullConfig) {
        try {
            return this.storageService.writeToFile(exports.TELEMETRY_CONFIG, JSON.stringify(fullConfig, null, 2));
        }
        catch (e) {
            console.error(`Error saving configuration locally: ${e}`);
        }
    }
    async fetchRemoteConfiguration(uri) {
        let telemetryUri = (uri) ? uri : envVar_1.default[ConfigurationManager.REMOTE_CONFIG_KEY];
        if (!telemetryUri) {
            telemetryUri = exports.DEFAULT_CONFIG_URL;
        }
        logger_1.Logger.info(`Updating vscode-redhat-telemetry configuration from ${telemetryUri}`);
        const response = await fetch(telemetryUri);
        try {
            return response?.json();
        }
        catch (e) {
            console.error(`Failed to parse:\n` + (await response?.text()) + '\n' + e);
        }
        return undefined;
    }
    async getLocalConfiguration() {
        const content = await this.storageService.readFromFile(exports.TELEMETRY_CONFIG);
        if (content) {
            return JSON.parse(content);
        }
        return undefined;
    }
    async getEmbeddedConfiguration() {
        return require('../../config/telemetry-config.json');
    }
}
exports.ConfigurationManager = ConfigurationManager;
ConfigurationManager.REMOTE_CONFIG_KEY = 'REDHAT_TELEMETRY_REMOTE_CONFIG_URL';
ConfigurationManager.TEST_CONFIG_KEY = 'REDHAT_TELEMETRY_TEST_CONFIG_KEY';
const refreshPattern = /\d+/g;
const REFRESH_PERIOD = 6;
const HOUR_IN_MILLISEC = 60 * 60 * 1000;
function isStale(configOrJson) {
    if (!configOrJson) {
        return true;
    }
    let config;
    if (configOrJson instanceof configuration_1.Configuration) {
        config = configOrJson.json;
    }
    else {
        config = configOrJson;
    }
    const timestamp = config.timestamp ? config.timestamp : 0;
    let period = REFRESH_PERIOD;
    if (config.refresh) {
        const res = config.refresh.match(refreshPattern);
        if (res && res.length) {
            period = parseInt(res[0]);
        }
    }
    let elapsed = new Date().getTime() - timestamp;
    return (elapsed > period * HOUR_IN_MILLISEC);
}
function getExtensionConfig(fullConfig, extensionId) {
    const extensionConfig = Object.assign({}, fullConfig['*'], fullConfig[extensionId]);
    if (fullConfig.timestamp) {
        extensionConfig['timestamp'] = fullConfig.timestamp;
    }
    return extensionConfig;
}
//# sourceMappingURL=configurationManager.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryServiceImpl = void 0;
const logger_1 = require("../utils/logger");
const events_1 = require("../utils/events");
const eventTracker_1 = require("./eventTracker");
/**
 * Implementation of a `TelemetryService`
 */
class TelemetryServiceImpl {
    constructor(globalState, reporter, queue, settings, idManager, environment, configurationManager) {
        this.reporter = reporter;
        this.queue = queue;
        this.settings = settings;
        this.idManager = idManager;
        this.environment = environment;
        this.configurationManager = configurationManager;
        this.startTime = this.getCurrentTimeInSeconds();
        this.eventTracker = new eventTracker_1.EventTracker(globalState);
    }
    /*
      Collects telemetry data and pushes to a queue when not opted in
      and to segment when user has opted for telemetry
    */
    async send(event) {
        logger_1.Logger.log(`Event received: ${event.name}`);
        if (this.settings.isTelemetryEnabled()) {
            // flush whatever was in the queue, however it's unlikely there's anything left at this point.
            this.flushQueue();
            this.sendEvent(event);
        }
        else if (!this.settings.isTelemetryConfigured()) {
            // Still waiting for opt-in?, then queue events
            this.queue?.addEvent(event);
        }
    }
    async sendStartupEvent() {
        this.startTime = this.getCurrentTimeInSeconds();
        return this.send({ name: 'startup' });
    }
    async sendShutdownEvent() {
        return this.send({ name: 'shutdown', properties: {
                //Sends session duration in seconds
                session_duration: this.getCurrentTimeInSeconds() - this.startTime
            } });
    }
    async sendEvent(event) {
        //Check against VS Code settings
        const level = this.settings.getTelemetryLevel();
        if (level && ["error", "crash"].includes(level) && !(0, events_1.isError)(event)) {
            return;
        }
        const userId = await this.idManager.getRedHatUUID();
        const payload = (0, events_1.transform)(event, userId, this.environment);
        //Check against Extension configuration
        const config = await this.configurationManager?.getExtensionConfiguration();
        if (!config || config.canSend(payload)) {
            const dailyLimit = (config) ? config.getDailyLimit(payload) : Number.MAX_VALUE;
            let count = 0;
            if (dailyLimit < Number.MAX_VALUE) {
                //find currently stored count
                count = await this.eventTracker.getEventCount(payload);
                if (count >= dailyLimit) {
                    //daily limit reached, do not send event
                    logger_1.Logger.log(`Daily limit reached for ${event.name}: ${dailyLimit}`);
                    return;
                }
            }
            return this.reporter.report(payload).then(() => {
                if (dailyLimit < Number.MAX_VALUE) {
                    //update count
                    logger_1.Logger.log(`Storing event count (${count + 1}/${dailyLimit}) for ${event.name}`);
                    return this.eventTracker.storeEventCount(payload, count + 1);
                }
            });
        }
    }
    async flushQueue() {
        const eventsToFlush = this.queue?.events;
        if (eventsToFlush && this.settings.isTelemetryEnabled()) {
            while (eventsToFlush.length > 0) {
                const event = this.queue?.events?.shift();
                if (event) {
                    this.sendEvent(event);
                }
            }
        }
        // No matter what, we need to empty the queue if it exists
        this.queue?.emptyQueue();
    }
    async dispose() {
        this.queue?.emptyQueue();
        return this.reporter.closeAndFlush();
    }
    getCurrentTimeInSeconds() {
        const now = Date.now();
        return Math.floor(now / 1000);
    }
}
exports.TelemetryServiceImpl = TelemetryServiceImpl;
//# sourceMappingURL=telemetryServiceImpl.js.map
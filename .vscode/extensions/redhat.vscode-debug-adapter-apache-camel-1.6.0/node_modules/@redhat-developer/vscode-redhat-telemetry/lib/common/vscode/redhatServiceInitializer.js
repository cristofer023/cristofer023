"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractRedHatServiceProvider = void 0;
const analytics_node_1 = __importDefault(require("@segment/analytics-node"));
const vscode_1 = require("vscode");
const logger_1 = require("../utils/logger");
const extensions_1 = require("../utils/extensions");
const settings_1 = require("../vscode/settings");
const fsUtils_1 = require("../vscode/fsUtils");
const constants_1 = require("../impl/constants");
const keyLocator_1 = require("../utils/keyLocator");
const RETRY_OPTIN_DELAY_IN_MS = 24 * 60 * 60 * 1000; // 24h
class AbstractRedHatServiceProvider {
    constructor(context) {
        this.settings = new settings_1.VSCodeSettings();
        this.context = context;
    }
    getSegmentApi(packageJson) {
        const writeKey = (0, keyLocator_1.getSegmentKey)(packageJson);
        const maxEventsInBatch = 1;
        const flushInterval = 1000;
        const httpRequestTimeout = 3000;
        return new analytics_node_1.default({ writeKey, maxEventsInBatch, flushInterval, httpRequestTimeout });
    }
    getCachePath() {
        return vscode_1.Uri.joinPath(this.getTelemetryWorkingDir(this.context), 'cache');
    }
    /**
     * Returns a new `RedHatService` instance for a Visual Studio Code extension. For telemetry, the following is performed:
     * - A preference listener enables/disables  telemetry based on changes to `redhat.telemetry.enabled`
     * - If `redhat.telemetry.enabled` is not set, a popup requesting telemetry opt-in will be displayed
     * - when the extension is deactivated, a telemetry shutdown event will be emitted (if telemetry is enabled)
     *
     * @param context the extension's context
     * @returns a Promise of RedHatService
     */
    async getRedHatService() {
        this.extensionInfo = await (0, extensions_1.getExtension)(this.context);
        this.extensionId = this.extensionInfo?.id;
        logger_1.Logger.extId = this.extensionId;
        const redhatService = await this.buildRedHatService();
        const telemetryService = await redhatService.getTelemetryService();
        // register disposable to send shutdown event
        this.context.subscriptions.push(shutdownHook(telemetryService));
        // register preference listener for that extension, 
        // so it stops/starts sending data when redhat.telemetry.enabled changes
        this.context.subscriptions.push(onDidChangeTelemetryEnabled(telemetryService));
        this.openTelemetryOptInDialogIfNeeded();
        telemetryService.send({
            type: 'identify',
            name: 'identify'
        });
        return redhatService;
    }
    getTelemetryWorkingDir(context) {
        return vscode_1.Uri.joinPath(context.globalStorageUri, '..', 'vscode-redhat-telemetry');
    }
    async openTelemetryOptInDialogIfNeeded() {
        if (this.settings.isTelemetryConfigured() || (0, settings_1.didUserDisableTelemetry)()) {
            return;
        }
        let popupInfo;
        const parentDir = this.getTelemetryWorkingDir(this.context);
        const optinPopupInfo = vscode_1.Uri.joinPath(parentDir, 'redhat.optin.json');
        if (await (0, fsUtils_1.exists)(optinPopupInfo)) {
            const rawdata = await (0, fsUtils_1.readFile)(optinPopupInfo);
            popupInfo = JSON.parse(rawdata);
        }
        if (popupInfo) {
            if (popupInfo.sessionId !== vscode_1.env.sessionId || popupInfo.owner !== this.extensionId) {
                //someone else is showing the popup, bail.
                return;
            }
        }
        else {
            popupInfo = {
                owner: this.extensionId,
                sessionId: vscode_1.env.sessionId,
                time: new Date().getTime() //for troubleshooting purposes
            };
            await (0, fsUtils_1.writeFile)(optinPopupInfo, JSON.stringify(popupInfo));
            this.context.subscriptions.push({
                dispose: () => { safeCleanup(optinPopupInfo); }
            });
        }
        const message = `Help Red Hat improve its extensions by allowing them to collect usage data. 
      Read our [privacy statement](${constants_1.PRIVACY_STATEMENT_URL}?from=${this.extensionId}) 
    and learn how to [opt out](${constants_1.OPT_OUT_INSTRUCTIONS_URL}?from=${this.extensionId}).`;
        const retryOptin = setTimeout(this.openTelemetryOptInDialogIfNeeded, RETRY_OPTIN_DELAY_IN_MS);
        let selection;
        try {
            selection = await vscode_1.window.showInformationMessage(message, 'Accept', 'Deny');
            if (!selection) {
                //close was chosen. Ask next time.
                return;
            }
            clearTimeout(retryOptin);
            this.settings.updateTelemetryEnabledConfig(selection === 'Accept');
        }
        finally {
            if (selection) {
                safeCleanup(optinPopupInfo);
            }
        }
    }
}
exports.AbstractRedHatServiceProvider = AbstractRedHatServiceProvider;
function onDidChangeTelemetryEnabled(telemetryService) {
    return vscode_1.workspace.onDidChangeConfiguration(
    //as soon as user changed the redhat.telemetry setting, we consider
    //opt-in (or out) has been set, so whichever the choice is, we flush the queue
    (e) => {
        if (e.affectsConfiguration("redhat.telemetry") || e.affectsConfiguration("telemetry")) {
            telemetryService.flushQueue();
        }
    });
}
function safeCleanup(filePath) {
    try {
        (0, fsUtils_1.deleteFile)(filePath);
    }
    catch (err) {
        logger_1.Logger.log(err);
    }
    logger_1.Logger.log(`Deleted ${filePath}`);
}
function shutdownHook(telemetryService) {
    return {
        dispose: async () => {
            await telemetryService.sendShutdownEvent();
            await telemetryService.dispose();
            logger_1.Logger.log("disposed telemetry service");
        }
    };
}
//# sourceMappingURL=redhatServiceInitializer.js.map